[{"title":"2024数学建模国赛","path":"/2024/09/03/计算机基础/数学建模2024/","content":"第二问思路是否对配件检验： 如果对配件检验：得到的配件一定是合格品，只需计算平均价值。 $E &#x3D; \\frac{(w+c)}{p}$ $p$表示合格品概率，$w$表示配件购买价格，$c$表示配件检验成本 不对配件检验：会提高成品的不合格率 是否对成品检验： 对成品检验：需要付出检验费用，但卖出的成品一定是合格品，所以不需要支付退还费用。 成本构成：1.合格品的成本（包括配件购买费用+配件检验费用） ；2.组装费用； 3.成品检验费用 ；4.不合格品的成本 对成品不检验：不需要检验费用，但卖出的成品有一部分是不合格品，需要支付退还费用。 成本构成： 枚举所有做法（第二问）首先考虑不拆解的情况 不检验配件A，不检验配件B，不检验成品，不拆解成品。 成品为合格品概率：$p(qualified) &#x3D; p_a * p_b * p_c$ 不合格品概率：$1 - p(qualified)$ 平均收益：$E &#x3D; p(qualified) * w - 1 * (cost) - (1-p(qualified))*(swap)$ 检验配件A，不检验配件B，不检验成品，不拆解成品。 配件A的平均成本：$\\frac{cost + c}{p}$ 成品为合格品概率：$p(qualified) &#x3D; p_b * p_c$ 平均收益：$E &#x3D; p(qualified) * w - 1*cost - (1-qualified)*swap$ 组成一件成品的价格：$cost &#x3D; cost_a + cost_b + eval_a + assemble$ 不检验配件A，检验配件B，不检验成品，不拆解成品。 原理同上 检验配件A，检验配件B，不检验成品，不拆解成品。 合格品概率：$p(qualified) &#x3D; p_c$ 平均收益：$E &#x3D; p(qualified) * w - 1 * cost - (1-p(qualified))*swap$ 生产价格：$cost &#x3D; E(cost_A) + E(cost_B) + assemble$ 综上所述：当不检验成品，且不拆解成品时，卖出每件产品的期望收益为： $E &#x3D; p(qualified) * w - 1*cost - p(unqualified) * swap$ 只是每种情况，计算生产成本的结果不同 不检验配件A，不检验配件B，检验成品，不拆解成品。 合格品概率：$p(qualified) &#x3D; p_A * p_B * p_C$ 销售收益：$p(qualified) * w$ 生产成本：$cost_A + cost_B + assemble + eval_C$ 检验配件A，不检验配件B，检验成品，不拆解成品。 合格品概率：$p(qualified) &#x3D; p_B * p_C$ 销售收益：$p(qualified) * w$ 成产成本：$E(cost_A) + cost_B + assemble + eval_C$ 平均收益：$E &#x3D; p(qualified) * w - 1*cost$ 不检验配件A，检验配件B，检验成品，不拆解成品 同6 检验配件A，检验配件B，检验成品，不拆解成品 $cost &#x3D; E(cost_A) + E(cost_B) + assemble + eval_C$ 综上所述：不拆解成品的情况下，所有方案 卖出一件的预期收益为： $E &#x3D; p(qualified) * w - 1 * cost - p(unqualified)*swap$ 是否检验配件，影响$cost$的计算； 是否检验成品，决定了售出成品的不合格率是否为0，可以减少退还损失。 其次考虑拆解成品的情况由于拆解的是检验不合格的成品，所以，当拆解成品时，必然伴随着检验成品。 不检验配件A，不检验配件B，检验成品，且拆解成品，且不进行二次检验。 暂时认为，这是一种很糟糕的策略，只有在次品率极低的情况下适用。 检验配件A，检验配件B，检验成品，且拆解成品，无需进行二次检验。 第i次合成成功的成本：$cost(i) &#x3D; E(cost_A) + E(cost_B) + i*assemble + (i-1)*melt$ 生产成本：$cost &#x3D; \\sum_{i&#x3D;1}^{\\infty} cost(i) $ 成品的合格率：$p(qualified) &#x3D; p_c$ 卖出一件产品的预期收益同上。 检验配件A，不检验配件B，检验成品，拆解成品，并对B进行二次检验 这里需要用到朴素贝叶斯公式！ 成品合格率：$p(qualified) &#x3D; p_B * p_C$ 仅因为组装问题导致为次品的概率为：$(1-p_C)*p_B$ ， 配件B损坏导致为次品的概率（包括了B既为次品，还组装失败的情况）：$1-p_B$ 由于所有配件都至多检验一次，一旦通过检验，则一定为合格品。 第i次合成成功的花费： $cost(i) &#x3D; E(cost_A) + cost_B + i*assemble + (i-1)*melt + (i&gt;1)?:0:1 * eval_c$ 生产成本： $cost &#x3D; p_bp_ccost(1) + (1-p_b)*(E(cost_A)+cost_B + assemble + eval_c) + p_b * (1-p_c)^{(i-1)} * p_c (E_(cost_A) + cost_B + iassemble + (i-1)*melt)$ 4.不检验A，B，检验成品，拆解成品，并对A，B进行二次检验。 $$cost &#x3D; \\sum_{i&#x3D;1}^{n} cost_i$$","categories":["其他"]},{"title":"rs232","path":"/2024/08/05/fpga/rs232/","content":"理论学习通信协议基础​ 通用异步收发传输器（Universal Asynchronous Receiver&#x2F;Transmitter），通常称作UART。UART是一种通用的数据通信协议，也是异步串行通信口（串口）的总称，它在发送数据时将并行数据转换成串行数据来传输，在接收数据时将接收到的串行数据转换成并行数据。它包括了RS 232、RS499、RS423、RS422和RS485等接口标准规范和总线标准规范。 ​ 串口作为常用的三大低速总线（UART、SPI、IIC）之一，在设计众多通信接口和调试时占有重要地位。但UART和SPI、IIC不同的是，它是异步通信接口，异步通信中的接收方并不知道数据什么时候会到达，所以双方收发端都要有各自的时钟，在数据传输过程中是不需要时钟的，发送方发送的时间间隔可以不均匀，接受 方是在数据的起始位和停止位的帮助下实现信息同步的。而SPI、IIC是同步通信接口（后面的章节会做详细介绍），同步通信中双方使用频率一致的时钟，在数据传输过程中时钟伴随着数据一起传输，发送方和接收方使用的时钟都是由主机提供的。 UART基础​ UART通信只有两根信号线，一根是发送数据端口线叫tx（Transmitter），一根是接收数据端口线叫rx（Receiver），对于PC来说它的tx要和对于FPGA来说的rx连接，同样PC的rx要和FPGA的tx连接。UART可以实现全双工，即可以同时进行发送数据和接收数据。 RS232优点​ 串口RS232传输数据的距离虽然不远，传输速率也相对较慢，但是串口依然被广泛的用于电路系统的设计中，串口的好处主要表现在以下几个方面： 很多传感器芯片或CPU都带有串口功能，目的是在使用一些传感器或CPU时可以通过串口进行调试，十分方便； 在较为复杂的高速数据接口和数据链路集合的系统中往往联合调试比较困难，可以先使用串口将数据链路部分验证后，再把串口换成高速数据接口。如在做以太网相关的项目时，可以在调试时先使用串口把整个数据链路调通，然后再把串口换成以太网的接口； 串口的数据线一共就两根，也没有时钟线，节省了大量的管脚资源。 RS232信号线​ 在旧式的台式计算机中一般会有 RS-232 标准的 COM 口(也称 DB9 接口)。 名称 符号 数据方向 说明 载波检测 DCD DTE→DCE Data Carrier Detect,数据载波检测，用于 DTE告知对方，本机是否收到对方的载波信 号 接收数据 RXD DTE&lt;DCE ReceiveData,数据接收信号，即输入。 发送数据 TXD DTE→DCE Transmit Data,数据发送信号，即输出。两个 设备之间的TXD与RXD应交叉相连 数据终端 (DTE)就 绪 DTR DTE→DCE Data Terminal Ready,数据终端就绪，用于 DTE向对方告知本机是否已准备好 信号地 GND 地线，两个通讯设备之间的地电位可能不一 样，这会影响收发双方的电平信号，所以两 个串口设备之间必须要使用地线连接，即共 地。 数据设备 (DCE)就 绪 DSR DTE&lt;DCE Data Set Ready,数据发送就绪，用于DCE告 知对方本机是否处于待命状态 请求发送 RTS DTE→DCE Request To Send,请求发送，DTE请求DCE 本设备向DCE端发送数据 允许发送 CTS DTE&lt;DCE Clear To Send,允许发送，DCE回应对方的 RTS发送请求，告知对方是否可以发送数据 响铃指示 RI DTE&lt;DCE Ring Indicator,响铃指示，表示DCE端与线 路已接通 RS232协议基础 RS232帧结构 ​\t在没有数据传输时，信道持续传输1，知道遇到一位0（起始位），标志着一帧数据的传输。 波特率：在信息传输通道中，携带数据信息的信号单元叫码元（因为串口是1bit进行传输的，所以其码元就是代表一个二进制数），每秒钟通过信号传输的码元数称为码元的传输速率，简称波特率，常用符号“Baud”表示，其单位为“波特每秒（Bps）”。串口常见的波特率有4800、9600、115200等。 比特率：每秒钟通信信道传输的信息量称为位传输速率，简称比特率，其单位为“每秒比特数（bps）”。比特率可由波特率计算得出，公式为：比特率&#x3D;波特率 * 单个调制状态对应的二进制位数。如果使用的是9600的波特率，其串口的比特率为：9600Bps * 1bit&#x3D; 9600bps。 由计算得串口发送或者接收1bit数据的时间为一个波特，即1&#x2F;9600秒，如果用50MHz（周期为20ns）的系统时钟来计数，需要计数的个数为cnt &#x3D; (1s * 10^9)ns &#x2F; 9600bit)ns &#x2F; 20ns ≈ 5208个系统时钟周期，即每个bit数据之间的间隔要在50MHz的时钟频率下计数5208次。 项目实战RS232 接收端模块该模块功能为：将串行数据转化为8位并行数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124module uart_rx // rs232接受模块 ： 需要把串行数据转化为并行数据#(\tparameter UART_BPS = &#x27;d9600, //串口波特率\tparameter CLK_FREQ = &#x27;d50_000_000 //时钟频率)(\tinput sys_clk,sys_rst_n, input rx,\toutput reg po_flag,\toutput reg [7:0] po_data);parameter BAUD_CNT_MAX = CLK_FREQ / UART_BPS;reg rx_reg1,rx_reg2,rx_reg3;\t// 将po_data打两拍消除亚稳态，reg3再打一拍检测下降沿（起始位）reg start_neg;\t// 数据开始标志位reg work_en;\t// 工作状态reg [12:0] baud_cnt;\t// 波特计数器reg bit_flag; // bit加信号reg [3:0] bit_cnt; // bit计数器reg rx_flag; // 输出传输完成信号reg [7:0] rx_data; // 数据移位寄存器// 第一级寄存器，复位状态为1 : // 当没有数据传输时，信道一直传输1，直到发现起始位0，产生一个下降沿，表示数据传输开始always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg1 &lt;= 1&#x27;b1;\telse rx_reg1 &lt;= rx;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg2 &lt;= 1&#x27;b1;\telse rx_reg2 &lt;= rx_reg1;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg3 &lt;= 1&#x27;b1;\telse rx_reg3 &lt;= rx_reg2;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) start_neg &lt;= 1&#x27;b0;\telse if(rx_reg2 == 1&#x27;b0 &amp;&amp; rx_reg3 == 1&#x27;b1 &amp;&amp; work_en == 1&#x27;b0) start_neg &lt;= 1&#x27;b1;\telse start_neg &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) work_en &lt;= 1&#x27;b0;\telse if(start_neg == 1&#x27;b1) work_en &lt;= 1&#x27;b1;\telse if(bit_cnt == 4&#x27;d8 &amp;&amp; bit_flag == 1&#x27;b1) work_en &lt;= 1&#x27;b0;\telse work_en &lt;= work_en;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) baud_cnt &lt;= 13&#x27;b0;\telse if(work_en == 1&#x27;b1) begin if(baud_cnt == BAUD_CNT_MAX - 1) baud_cnt &lt;= 13&#x27;b0; else baud_cnt &lt;= baud_cnt + 1; end\telse baud_cnt &lt;= 13&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) bit_flag &lt;= 1&#x27;b0;\telse if(baud_cnt == (BAUD_CNT_MAX &gt;&gt; 1)) bit_flag &lt;= 1&#x27;b1;\telse bit_flag &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) bit_cnt &lt;= 4&#x27;b0;\telse if(bit_flag == 1&#x27;b1) begin if(bit_cnt == 4&#x27;d8) bit_cnt &lt;= 4&#x27;b0; else bit_cnt &lt;= bit_cnt + 1; end\telse bit_cnt &lt;= bit_cnt;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_data &lt;= 8&#x27;b0;\telse if(bit_flag == 1&#x27;b1 &amp;&amp; (bit_cnt &gt;= 1 &amp;&amp; bit_cnt &lt;= 8)) rx_data &lt;= &#123;rx_reg3,rx_data[7:1]&#125;;\telse rx_data &lt;= rx_data;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_flag &lt;= 1&#x27;b0;\telse if(bit_cnt == 4&#x27;d8 &amp;&amp; bit_flag == 1&#x27;b1) rx_flag &lt;= 1&#x27;b1;\telse rx_flag &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) po_data &lt;= 8&#x27;b0;\telse if(rx_flag == 1&#x27;b1) po_data &lt;= rx_data;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) po_flag &lt;= 1&#x27;b0;\telse if(rx_flag == 1&#x27;b1) po_flag &lt;= rx_flag;endmodule RS232发送端模块该模块功能为：将8位并行数据转化为串行数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980module uart_tx\t// rs232发送模块，把并行数据转化为串行#(\tparameter UART_BPS = &#x27;d9600,\tparameter CLK_FREQ = &#x27;d50_000_000)(\tinput sys_clk,sys_rst_n, input pi_flag, input [7:0] pi_data,\toutput reg tx );parameter BAUD_CNT_MAX = CLK_FREQ / UART_BPS;reg [12:0] baud_cnt;reg bit_flag;reg [3:0] bit_cnt;reg work_en;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) work_en &lt;= 1&#x27;b0;\telse if(pi_flag == 1&#x27;b1) work_en &lt;= 1&#x27;b1;\telse if(bit_cnt == 4&#x27;d9 &amp;&amp; bit_flag == 1&#x27;b1) work_en &lt;= 1&#x27;b0;\telse work_en &lt;= work_en;always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) baud_cnt &lt;= 13&#x27;b0; else if(work_en == 1&#x27;b1) begin if(baud_cnt == BAUD_CNT_MAX - 1) baud_cnt &lt;= 13&#x27;b0; else baud_cnt &lt;= baud_cnt + 1; end else baud_cnt &lt;= 13&#x27;b0; always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) bit_flag &lt;= 1&#x27;b0; else if(baud_cnt == 1) bit_flag &lt;= 1&#x27;b1; else bit_flag &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) bit_cnt &lt;= 4&#x27;b0;\telse if(bit_flag == 1&#x27;b1 &amp;&amp; bit_cnt == 4&#x27;d9) bit_cnt &lt;= 4&#x27;b0;\telse if(bit_flag == 1&#x27;b1 &amp;&amp; work_en == 1&#x27;b1) bit_cnt &lt;= bit_cnt + 1;\telse bit_cnt &lt;= bit_cnt;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) tx &lt;= 1&#x27;b1;\telse if(bit_flag == 1&#x27;b1) case(bit_cnt) 0 : tx &lt;= 1&#x27;b0; 1 : tx &lt;= pi_data[0]; 2 : tx &lt;= pi_data[1]; 3 : tx &lt;= pi_data[2]; 4 : tx &lt;= pi_data[3]; 5 : tx &lt;= pi_data[4]; 6 : tx &lt;= pi_data[5]; 7 : tx &lt;= pi_data[6]; 8 : tx &lt;= pi_data[7]; 9 : tx &lt;= 1&#x27;b1; default : tx &lt;= 1&#x27;b1; endcaseendmodule 学习链接笔记摘自：野火fpga开发实战指南：串口RS232 其他： 详解 | 还不懂串口通信？看这篇！","categories":["fpga"]},{"title":"rs485","path":"/2024/08/05/fpga/rs485/","content":"理论基础RS-485是双向、半双工通信协议，信号采用差分传输方式，允许多个驱动器和接收器挂接在总线上，其中每个驱动器都能够脱离总线。 RS-232是双向、全双工通信协议，信号采用单端传输方式。 差分传输有更好的抗干扰能力。 其次，485相对232可以进行长距离的信号传输；使用收发器，对电压敏感（200mv），传输距离（1200m），传输最大速率（10mb&#x2F;s）。但485只支持半双工。","categories":["fpga"]},{"title":"基于rs232的lcd图像显示","path":"/2024/08/05/fpga/uart_lcd/","content":"1.使用uart_rx模块作为图像接受模块 波特率的计算 波特率：每秒钟通过信号传输的码元数称为码元的传输速率 使用时钟频率 除以 波特率 可以得到传输每个码源所占用的时钟周期数 $baud_cnt_max &#x3D; \\frac{时钟频率}{波特率} $ 为什么要做打两拍操作 消除亚稳态，稳定信号。 在找下降沿时，不能使用$rx_reg1$ 和$rx_reg2$ 求得，因为$rx_reg1$ 信号不稳定，使用其求得的结果也不稳定，因此将 $rx_reg2$再打一拍，使用$rx_reg2$ 和 $rx_reg3$ 求得。 代码中 $bit_cnt$ 只计数到8 这是因为没有计数停止位，所以只有0~8 共计数 9位（1位起始位+8位数据位）。 rs232数据移位方向： 最先传输的比特在低位，最后传输的比特在高位 PC机通过串口调试助手往FPGA发8bit数据时，FPGA通过串口线rx一位一位地接收，从最低位到最高位依次接收，最后在FPGA里面位拼接成8比特数据。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119module uart_rx#parameter(\tparameter UART_BPS = &#x27;d9600, CLK_FREQ = &#x27;d50_000_000)(\tinput sys_clk,sys_rst_n, input rx, output reg [7:0] po_data,\toutput reg po_flag);localparam BAUD_CNT_MAX = CLK_FREQ / UART_BPS;reg rx_reg1;reg rx_reg2;reg rx_reg3;reg start_nedge;reg work_en;reg [12:0] baud_cnt;reg bit_flag;reg [3:0] bit_cnt;reg [7:0] rx_data;reg rx_flag;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg1 &lt;= 1&#x27;b0;\telse rx_reg1 &lt;= rx;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg2 &lt;= 1&#x27;b0;\telse rx_reg2 &lt;= rx_reg1;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_reg3 &lt;= 1&#x27;b0;\telse rx_reg3 &lt;= rx_reg2;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) start_nedge &lt;= 1&#x27;b0;\telse if(rx_reg2 == 1&#x27;b0 &amp;&amp; rx_reg3 == 1&#x27;b1) start_nedge &lt;= 1&#x27;b1;\telse start_nedge &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) work_en &lt;= 1&#x27;b0;\telse if(start_nedge == 1&#x27;b1)\t// 开始工作条件 work_en &lt;= 1&#x27;b1;\telse if(bit_cnt == 4&#x27;d8 &amp;&amp; bit_flag == 1&#x27;b1) // 停止工作条件：完成一个字节的传输 work_en &lt;= 1&#x27;b0;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) baud_cnt &lt;= 13&#x27;b0;\telse if(baud_cnt == BAUD_CNT_MAX - 1 &amp;&amp; work_en == 1&#x27;b1) baud_cnt &lt;= 13&#x27;b0;\telse if(work_en == 1&#x27;b1) baud_cnt &lt;= baud_cnt + 1;\telse baud_cnt &lt;= 13&#x27;b0;\t// 传输完成，停止工作，波特计数器清零always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) bit_flag &lt;= 1&#x27;b0;\telse if(baud_cnt == BAUD_CNT_MAX / 2 - 1) bit_flag &lt;= 1&#x27;b1;\telse bit_flag &lt;= 1&#x27;b0;// 这里由于没有计数停止位，所以只对0~8计数// 传输停止位时已经将work_en拉低，不会使bit_flag有效，因此bit_cnt也不会计数always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) bit_cnt &lt;= 4&#x27;b0;\telse if(bit_cnt == 4&#x27;d8 &amp;&amp; bit_flag == 1&#x27;b1) bit_cnt &lt;= 4&#x27;d0;\telse if(bit_flag == 1&#x27;b1) bit_cnt &lt;= bit_cnt + 1;// 对数据进行移位always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_data &lt;= 8&#x27;b0;\telse if(bit_flag == 1&#x27;b1 &amp;&amp; bit_cnt &gt;= 4&#x27;d1 &amp;&amp; bit_cnt &lt;= 4&#x27;d8) rx_data = &#123;rx_reg3,rx_data[7:1]&#125;;// 传输完8比特，拉高rx_flagalways@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) rx_flag &lt;= 1&#x27;b0;\telse if(bit_cnt == 4&#x27;d8 &amp;&amp; bit_flag == 1&#x27;b1)\t// 8位的最后一个比特传输完成 rx_flag &lt;= 1&#x27;b1;\telse rx_flag &lt;= 1&#x27;b0;// po_data 和 po_flag 都以 rx_data 为基准，可以实现统一时间输出always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) po_data &lt;= 8&#x27;b0;\telse if(rx_flag == 1&#x27;b1) po_data &lt;= rx_data;always@(posedge sys_clk or negedge sys_rst_n)\tif(sys_rst_n == 1&#x27;b0) po_flag &lt;= 1&#x27;b0;\telse po_flag &lt;= rx_flag;endmodule","categories":["fpga"]},{"title":"Sublime快捷键","path":"/2024/08/03/工具使用基础/sublime快捷键/","content":"Sublime快捷键查找替换查找 ： Ctrl + F 查找替换 ：Ctrl + H","categories":["计算机基础"]},{"title":"Git基础","path":"/2024/08/03/计算机基础/Git/","content":"一.git基础 初始化git仓库 1git init 添加文件 1git add readme.txt 提交文件 1git commit -m &quot;submit infomation&quot; 查看工作区状态 1git status 查看修改内容 1git diff 查看提交历史 12git loggit reflog 回退版本 1git reset --hard 7376(版本号) 撤销暂存区的修改 1git reset HEAD readme.txt 撤销工作区的修改 1git checkout -- readme.txt 删除版本库的文件 1git rm readme.txt 管理github仓库 123git remote add origin git@github.com:skyang1/learngit.gitgit remote -v // 查看关联仓库 推送本地库的所有内容到github 1git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 克隆github项目 1git clone git@github.com:LeiWang1999/FPGA.git 二、分支管理 查看分支 1git branch 创建分支 1git branch dev 切换分支 12git switch devgit checkout dev 创建并切换分支 12git switch -c devgit checkout -b dev 合并某分支到当前分支 1git merge dev 删除分支 1git branch -d dev","tags":["git","linux"],"categories":["计算机基础"]},{"path":"/about/index.html","content":"下面写关于自己的内容"},{"title":"我的朋友们","path":"/friends/index.html","content":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"Hexo-stellar配置","path":"/wiki/diary/example.html","content":"今天主要问题在文档的配置，按照官方教程无法配置成功，更改项目结构后配置成功。 新的项目结构为： wiki.yml ：文档目录，存放在source&#x2F;_data目录下- diary 1- diary diary.yml ：日记文档的配置文件，存放到source&#x2F;_data&#x2F;wiki目录下 123456789101112131415161718192021222324252627name: Diarytitle: skyang-学习日记subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27;tags: 日记icon: /assets/wiki/stellar/icon.svgcover: /assets/wiki/stellar/icon.svgdescription: skyang学习日记-每天学习的一些零碎的知识，难以整理，写为日记# repo: xaoxuu/hexo-theme-stellarsearch: filter: /wiki/stellar/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_stellar_releases - related# comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27;# comments:# service: giscus# giscus:# data-repo: xaoxuu/hexo-theme-stellar# data-mapping: number# data-term: 226base_dir: /wiki/stellar/tree: &#x27;快速开始&#x27;: - index\t- day_20241210 day_20241210.md ：文档具体内容，存放在myblog&#x2F;wiki&#x2F;diary路径下"},{"title":"日记首页","path":"/wiki/diary/index.html","content":"记录一下每日学习日常，以零散笔记为主。"},{"title":"Hexo-stellar配置","path":"/wiki/diary/stellar.html","content":"今天主要问题在文档的配置，按照官方教程无法配置成功，更改项目结构后配置成功。 新的项目结构为： wiki.yml ：文档目录，存放在source&#x2F;_data目录下- diary 1- diary diary.yml ：日记文档的配置文件，存放到source&#x2F;_data&#x2F;wiki目录下 123456789101112131415161718192021222324252627name: Diarytitle: skyang-学习日记subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27;tags: 日记icon: /assets/wiki/stellar/icon.svgcover: /assets/wiki/stellar/icon.svgdescription: skyang学习日记-每天学习的一些零碎的知识，难以整理，写为日记# repo: xaoxuu/hexo-theme-stellarsearch: filter: /wiki/stellar/ placeholder: 在 Stellar 中搜索...leftbar: - tree - timeline_stellar_releases - related# comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27;# comments:# service: giscus# giscus:# data-repo: xaoxuu/hexo-theme-stellar# data-mapping: number# data-term: 226base_dir: /wiki/stellar/tree: &#x27;快速开始&#x27;: - index\t- day_20241210 day_20241210.md ：文档具体内容，存放在myblog&#x2F;wiki&#x2F;diary路径下"},{"title":"npm安装软件包","path":"/wiki/diary/npm.html","content":"npm安装软件包全局安装1nmp install hexo -g 安装的软件包在NodeJS安装目录下的global_modules文件夹下 本地安装安装到当前路径的文件夹下 由于没有配置全局环境变量，可以使用 npx 指令使用安装的软件包 1npx hexo g -d"}]